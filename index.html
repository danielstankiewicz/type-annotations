<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>Java 8: Type Annotations</title>
    <script src="http://gnab.github.io/remark/downloads/remark-0.6.4.min.js" type="text/javascript"> </script>
    <style type="text/css">
      @import url(http://fonts.googleapis.com/css?family=Signika:300);
      @import url(http://fonts.googleapis.com/css?family=Source+Code+Pro);
      @import url(http://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);

      body { 
        font-family: 'Signika';
        font-weight: 300;
        font-size: 18pt;
      }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: 400;
        margin-bottom: 0;
        margin-top: 10px;
      }
      h1 { font-size: 2.5em; }
      h2 { font-size: 2em; }
      h3 { font-size: 1.5em; }

      .inverse {
        background: #272822;
        color: #a5a5a5;
      }
      .inverse h1 {
        color: #f3f3f3;
        line-height: 1.5em;
      }
      .inverse h2, .inverse h3 {
        color: #a5a5a5;
        line-height: 0.8em;
      }
      .inverse em {
        color: #f3f3f3;
        font-style: normal;
      }
      pre {
        border-left: 0.2em solid #d7d7d7;
        padding: 0.3em !important;
      }
      code {
        font-family: 'Source Code Pro';
        font-size: 0.72em;
      }
      a {
        color: #F92672;
        text-decoration: none;
      }
      .right {
        float: right;
        margin-left: 1em;
      }
      .pushdown {
        margin-top: 12em;
      }
      .pull-left {
        float: left;
        width: 47%;
      }
      .pull-right {
        float: right;
        width: 47%;
      }
      .blue {
        color: #4A6BD9;
      }
      .red {
        color: #C90000;
      }
      .green {
        color: #1FAB3B;
      }

    </style>
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse
# Java 8: Type Annotations

## by [Daniel Stankiewicz](https://github.com/danielstankiewicz)

???

http://openjdk.java.net/projects/type-annotations/

http://docs.oracle.com/javase/specs/

http://docs.oracle.com/javase/specs/jls/se8/jls8­diffs.pdf

http://docs.oracle.com/javase/specs/jls/se8/html/jls-9.html#jls-9.6.4.1

http://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.11

3. JSR­308 najbardziej innowacyjny JSR roku... 2007
4. wcześniej adnotacje występowały tylko w kontekście deklaracji
    * ElementType.PACKAGE
    * ElementType.TYPE
    * ElementType.FIELD
    * ElementType.CONSTRUCTOR
    * ElementType.METHOD
    * ElementType.PARAMETER
    * ElementType.LOCAL_VARIABLE
5. do tej pory wszystkie poza LOCAL_VARIABLE mogły być odczytywane w runtime, do deklaracji zmiennej lokalnej nie można się było
dostać przez refleksję, była od początku projektowana jako służąca do warningów kompilatora
6. do kontekstu deklaracji został dodany typ ElementType.TYPE_PARAMETER, czyli adnotacja przy deklaracji typu generycznego w klasie lub metodzie
7. pojawił się nowy kontekst, typu, czyli wszystkie miejsca, w których typy są użyte w deklaracjach i wyrażeniach, odpowiada mu ElementType.TYPE_USE. Dodatkowo
TYPE_USE zawiera w sobie elementy z kontekstu deklaracji: deklaracje typu i typu generycznego.
8.  Gdzie można użyć adnotacji TYPE_USE? Gdzie nie można użyć?

---
class: center, middle, inverse
# about.me
### (mostly) Java Developer since 2005
### currently [@AssecoPolandSA](http://asseco.com/pl/home-en/)
### *inspired by Java 8*
### privately husband, dad, guitarist

---
class: center, middle, inverse
# Java 8 New Features
## and Type Annotations amongst them

---
layout: true

### Java 8 New Features

---
## Annotations on Java Types (JSR-308)
Browsing [JDK 8 Features](http://openjdk.java.net/projects/jdk8/features) in `core/lang` group:

* 101 Generalized Target-Type Inference
* .blue[**104 Annotations on Java Types**]
* 105 DocTree API
* 106 Add Javadoc to `javax.tools`
* 117 Remove the Annotation-Processing Tool (apt)
* 118 Access to Parameter Names at Runtime
* 120 Repeating Annotations
* ...

A brief look at [Open JDK Type Annotations](http://openjdk.java.net/projects/type-annotations/) project:

*JSR 308, Annotations on Java Types lays the foundations for stronger typing in Java by extending
the language to .blue[**allow annotations**] on essentially .blue[**any use of a type**].*

---
## First Naive Test
An even more brief look at `ElementType.TYPE_USE` [javadoc](http://docs.oracle.com/javase/8/docs/api/java/lang/annotation/ElementType.html#TYPE_USE)
and then a first naive test:
```
public List<@TypeUse String> typeUse() {
    @TypeUse String s = "abc";
    List<@TypeUse String> list = new ArrayList<>();
    list.add(s);
    list.add("def");
    boolean isTypeUse = "def" instanceof @TypeUse String;
    System.out.println("@TypeUse String: " + isTypeUse);
    return list;
}
```
**Wow! No compilation errors!!!**

---
layout: false
class: center, middle, inverse
# A Deeper Dive into Specification
## or a piece of more organized knowledge

---
layout: true
### A Deeper Dive into Specification

---
## Declaration vs type context

Before Java 8 annotations could be used only in *declaration contexts*, that is in declarations of types, fields, methods, constructors etc.
All the declarations contexts except for `ElementType.LOCAL_VARIABLE` could be accessed by reflection.

Java 8 extends *declaration context* to the use of **generic type parameter declarations**.

Additionally it introduces *type context*, where annotations apply to **types used in declarations and expressions**.

---
## Declaration context
* ElementType.PACKAGE
* ElementType.TYPE
* ElementType.ANNOTATION_TYPE
* ElementType.FIELD
* ElementType.CONSTRUCTOR
* ElementType.METHOD
* ElementType.PARAMETER
* .red[ElementType.LOCAL_VARIABLE]

---
## Declaration context
* ElementType.PACKAGE
* ElementType.TYPE
* ElementType.ANNOTATION_TYPE
* ElementType.FIELD
* ElementType.CONSTRUCTOR
* ElementType.METHOD
* ElementType.PARAMETER
* ElementType.LOCAL_VARIABLE
* .green[ElementType.TYPE_PARAMETER]

--

##.green[Type context]
* .green[ElementType.TYPE_USE]

---
## Declaration context
* ElementType.PACKAGE
* .blue[ElementType.TYPE]
* .blue[ElementType.ANNOTATION_TYPE]
* ElementType.FIELD
* ElementType.CONSTRUCTOR
* ElementType.METHOD
* ElementType.PARAMETER
* ElementType.LOCAL_VARIABLE
* .blue[ElementType.TYPE_PARAMETER]

## Type context
* .blue[ElementType.TYPE_USE]

`ElementType.TYPE_USE` for convenience .blue[includes elements of declaration context]: types, annotation types and type parameters.

---
## ElementType.TYPE_PARAMETER usages

Type parameter of generic class (or interface)
```
public class GenericClass<@TypeParameter("class") V extends Number>
```
Type parameter of generic constructor
```
public <@TypeParameter("constructor") A> GenericClass(V value, A another)
```
Type parameter of generic method
```
public <@TypeParameter("method") K> Map<K, V> getSingletonMap(K key)
```

---
## ElementType.TYPE_PARAMETER reflection

Since Java 8 `java.lang.reflect.TypeVariable` interface extends `java.lang.reflect.AnnotatedElement` interface. Thus we can
access type parameter annotations like in the following code:

```
TypeVariable<Class<GenericClass>>[] typeParameters =
    GenericClass.class.getTypeParameters();
TypeParameter annotation =
        typeParameters[0].getAnnotation(TypeParameter.class);
```

---
## ElementType.TYPE_USE usages
### Declaration context
```
@TypeUse("class")
public class DeclarationContext<@TypeUse("type parameter") V extends Number> {
    public <@TypeUse("type parameter") K> Map<K, V> getSingletonMap(K key) {
        return Collections.singletonMap(key, this.value);
    }

    @TypeUse("annotation")
    public @interface AnnotationExample {}

    @TypeUse("interface")
    public interface InterfaceExample {}

    @TypeUse("enum")
    public enum EnumExample {}
}
```
Usages of `ElementType.TYPE_USE` in declaration contexts can be easily accessed by reflection.
---
## ElementType.TYPE_USE usages
### Type context in declarations

A type in the extends or implements clause of a class declaration
```
public class TypeContext implements @TypeUse Serializable
```
A type in the extends clause of an interface declaration
```
public interface InterfaceExample extends @TypeUse Runnable
```
The return type of a method (including the type of an element of an annotation type)
```
public @TypeUse String getValue()
```
---
## ElementType.TYPE_USE usages
### Type context in declarations

A type in the throws clause of a method or constructor
```
public void throwException() throws @TypeUse Exception
```
A type in the extends clause of a type parameter declaration of a generic class, interface, method, or constructor
```
public <N extends @TypeUse Number> Integer getInteger(N number)
```
The type in a field declaration of a class or interface (including an enum constant)
```
private @TypeUse String value;
private enum Status {@TypeUse OK, @TypeUse ERROR}
```
---
## ElementType.TYPE_USE usages
### Type context in declarations

The type in a formal parameter declaration of a method, constructor, or lambda expression
```
public List<Car> filterCars(@TypeUse List<Car> cars, int year) {
    return cars.stream()
            .filter((@TypeUse Car c) -> c.getYear() == year)
            .collect(Collectors.toList());
}
```
The type of the receiver parameter of a method
```
public void show(@TypeUse TypeContext this, boolean other)
```
---
## ElementType.TYPE_USE usages
### Type context in declarations

The type in a local variable declaration
```
@TypeUse Date date;
```
The type in an exception parameter declaration
```
catch (@TypeUse NumberFormatException e)
```

---
## ElementType.TYPE_USE usages
### .red[Type context in declarations != Declaration context]

Note that use of annotation of `ElementType.TYPE_USE` target in declarations of a field, method or
constructor return type, formal parameter of a method and a local variable may look like use of
annotations of declaration context: `FIELD`, `METHOD`, `CONSTRUCTOR`, `PARAMETER` and `LOCAL_VARIABLE` respectively.

.red[Don't be tricked!] These are not declaration context usages and can't be accessed by reflection. For example:
```
TypeContext.class.getDeclaredField("value")
        .getDeclaredAnnotation(TypeUse.class)
```
returns `null` in case field is declared as `private @TypeUse String value;`
---
## ElementType.TYPE_USE usages
### Type context in expressions

A type in the explicit type argument list to an explicit constructor invocation statement or class instance creation expression or method invocation expression
```
<@TypeUse Long>this(0l);
new <@TypeUse String> GenericClass<@TypeUse Long>(123l, "abc")
        .<@TypeUse Integer> getSingletonMap(123);

```
In an unqualified class instance creation expression, as the class type to be instantiated or as the direct superclass or direct superinterface of an anonymous class to be instantiated
```
new @TypeUse Thread(new @TypeUse Runnable() {
    @Override
    public void run() {}
});

```
---
## ElementType.TYPE_USE usages
### Type context in expressions

The element type in an array creation expression
```
Integer[] array = new Integer @TypeUse[] {};
```
The type in the cast operator of a cast expression
```
String s = (@TypeUse String) "abc";
```
The type that follows the `instanceof` relational operator
```
boolean isInstance = s instanceof @TypeUse String;
```
---
## ElementType.TYPE_USE usages
### Type context in expressions

In a method reference expression, as the reference type to search for a member method or as the class type or array type to construct
```
@TypeUse GenericClass::new
List<@TypeUse String>::size
Arrays::<@TypeUse Integer> sort
```

The element type of an array type
```
@TypeUse int[] a;    // annotates the primitive type int
int @TypeUse[] b;    // annotates the array type int[]
int @TypeUse[][] c;  // annotates the array type int[][]
int [] @TypeUse[] d; // annotates the array type int[] as component
                     // of array int[][]
```

---
## ElementType.TYPE_USE usages
### Type context in expressions

A non-wildcard type argument, or a bound of a wildcard type argument, of a parameterized type
```
List<@TypeUse Integer> integers;
Set<? extends @TypeUse Number> set;
Collection<? super @TypeUse Number> collection = new ArrayList<>();
```
---
## .red[Quasi ElementType.TYPE_USE usages]

.red[Warning! The following are not type uses and such annotations are not allowed here]

```
// Annotation uses
@/* quasi @TypeUse */Deprecated String s;

// Class literal
Class<GenericClass> clazz = /* quasi @TypeUse */GenericClass.class;

// Import syntax
import java.io./* quasi @TypeUse */Serializable;

// Static member access
String title = /* quasi @TypeUse */ GenericClass.TITLE;

// Scoping (e.g. inner class)
String v = /* quasi @TypeUse */TypeContext.this.getValue();
```

---
layout: false
class: center, middle, inverse
# The Checker Framework
## or who is the main culprit?

---
layout: true
### The Checker Framework

---
## A piece of history

* Annotations on Java Types (JSR-308) won the Most Innovative Java SE/EE JSR of the Year award in... 2007 :)
* Rationale for this JSR was to allow building tools for more thorough source code analysis
* [The Checker Framework](http://types.cs.washington.edu/checker-framework/), an extendable set of compiler plugins that
  find bugs or verify their absence, was naturally the first tool to use JSR-308 specification
* They didn't waste their time for those 7 years and the framework with a bunch of tools is already up and running:
    * **Type annotations compiler** - replacing `javac`, processing also annotations written in comments: `/* @TypeUse */`
    * **Inference tools** - automatically adding annotations to your code
    * **Annotations File Utilities** - to process `.java` and `.class` files, write annotations in a separate file etc.
* Better late than never - .red[type annotations in Java 8] in 2014 :)

---
## What we have out of the box?
.pull-left[
* Nullness Checker
* Initialization Checker
* Map Key Checker
* Interning Checker
* Lock Checker
* Fake Enum Checker
* Tainting Checker
* Regex Checker
]
.pull-right[
* Format String Checker
* Property File Checker
* Internationalization Checker
* Signature String Checker
* Units Checker
* Linear Checker
* Mutation Checkers
* Subtyping Checker
]

Let's prevent an SQL-injection by using **Tainting Checker**!

???

1. Nullness Checker - null pointer errors
1. Initialization Checker - czy wszystkie pola ustawione w konstruktorze
1. Map Key Checker - jakie wartosci sa kluczami w mapach
1. Interning Checker - bledy uzycia porownania referencji zamiast equals
1. Lock Checker - bledy wspolbieznosci i blokowania
1. Fake Enum Checker - stale string int jako enumy
1. Tainting Checker - bledy bezpieczenstwa, sql injection
1. Regex Checker - prawidlowe wyrazenia regularne
1. Format String Checker - prawidlowe stringi formatujace
1. Property File Checker - prawidlowe klucze plikow properties
1. Internationalization Checker - prawidlowa internacjonalizacja
1. Signature String Checker - Class.forName, odpowiednie uzycie nazw klas
1. Units Checker - uzycie odpowiednich jednostek (np sekundy a milisekundy)
1. Linear Checker - zapobieganie re-uzywaniu referencji
1. Mutation Checkers - niepozadane efekty uboczne
1. Subtyping Checker - kwalifikatory typu

---
## Tainting Checker

---
layout: false
class: center, middle, inverse

# That's all folks!

Slideshow created with [remark](http://gnab.github.com/remark).

    </textarea>
    <script>
      var slideshow = remark.create({
            ratio: '4:3',
            highlightLanguage: 'java', 
            highlightStyle: 'github'
      });
    </script>
  </body>
</html>