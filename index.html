<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>Java 8: Type Annotations</title>
    <script src="http://gnab.github.io/remark/downloads/remark-0.6.4.min.js" type="text/javascript"> </script>
    <style type="text/css">
      @import url(http://fonts.googleapis.com/css?family=Signika:300);
      @import url(http://fonts.googleapis.com/css?family=Source+Code+Pro);
      @import url(http://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);

      body { 
        font-family: 'Signika';
        font-weight: 300;
        font-size: 18pt;
      }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: 400;
        margin-bottom: 0;
        margin-top: 10px;
      }
      h1 { font-size: 2.5em; }
      h2 { font-size: 2em; }
      h3 { font-size: 1.5em; }

      .inverse {
        background: #272822;
        color: #a5a5a5;
      }
      .inverse h1 {
        color: #f3f3f3;
        line-height: 1.5em;
      }
      .inverse h2, .inverse h3 {
        color: #a5a5a5;
        line-height: 0.8em;
      }
      .inverse em {
        color: #f3f3f3;
        font-style: normal;
      }
      pre {
        border-left: 0.2em solid #d7d7d7;
        padding: 0.3em !important;
      }
      code {
        font-family: 'Source Code Pro';
        font-size: 0.72em;
      }
      a {
        color: #F92672;
        text-decoration: none;
      }
      .right {
        float: right;
        margin-left: 1em;
      }
      .pushdown {
        margin-top: 12em;
      }
      .pull-left {
        float: left;
        width: 47%;
      }
      .pull-right {
        float: right;
        width: 47%;
      }
      .blue {
        color: #4A6BD9;
      }
      .red {
        color: #C90000;
      }
      .green {
        color: #1FAB3B;
      }
      img[alt=tainting] {
        width: 60%;
      }

    </style>
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse
# Java 8: Type Annotations

## by [Daniel Stankiewicz](https://github.com/danielstankiewicz)

???

http://openjdk.java.net/projects/type-annotations/

http://docs.oracle.com/javase/specs/

http://docs.oracle.com/javase/specs/jls/se8/jls8­diffs.pdf

http://docs.oracle.com/javase/specs/jls/se8/html/jls-9.html#jls-9.6.4.1

http://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.11

3. JSR­308 najbardziej innowacyjny JSR roku... 2007
4. wcześniej adnotacje występowały tylko w kontekście deklaracji
    * ElementType.PACKAGE
    * ElementType.TYPE
    * ElementType.FIELD
    * ElementType.CONSTRUCTOR
    * ElementType.METHOD
    * ElementType.PARAMETER
    * ElementType.LOCAL_VARIABLE
5. do tej pory wszystkie poza LOCAL_VARIABLE mogły być odczytywane w runtime, do deklaracji zmiennej lokalnej nie można się było
dostać przez refleksję, była od początku projektowana jako służąca do warningów kompilatora
6. do kontekstu deklaracji został dodany typ ElementType.TYPE_PARAMETER, czyli adnotacja przy deklaracji typu generycznego w klasie lub metodzie
7. pojawił się nowy kontekst, typu, czyli wszystkie miejsca, w których typy są użyte w deklaracjach i wyrażeniach, odpowiada mu ElementType.TYPE_USE. Dodatkowo
TYPE_USE zawiera w sobie elementy z kontekstu deklaracji: deklaracje typu i typu generycznego.
8.  Gdzie można użyć adnotacji TYPE_USE? Gdzie nie można użyć?

---
class: center, middle, inverse
# about.me
### (mostly) Java Developer since 2005
### currently [@AssecoPolandSA](http://asseco.com/pl/home-en/)
### *inspired by Java 8*
### privately husband, dad, guitarist

---
class: center, middle, inverse
# Java 8 New Features
## and Type Annotations amongst them

---
layout: true

### Java 8 New Features

---
## Annotations on Java Types (JSR-308)
Browsing [JDK 8 Features](http://openjdk.java.net/projects/jdk8/features) in `core/lang` group:

* 101 Generalized Target-Type Inference
* .blue[**104 Annotations on Java Types**]
* 105 DocTree API
* 106 Add Javadoc to `javax.tools`
* 117 Remove the Annotation-Processing Tool (apt)
* 118 Access to Parameter Names at Runtime
* 120 Repeating Annotations
* ...

A brief look at [Open JDK Type Annotations](http://openjdk.java.net/projects/type-annotations/) project:

*JSR 308, Annotations on Java Types lays the foundations for stronger typing in Java by extending
the language to .blue[**allow annotations**] on essentially .blue[**any use of a type**].*

---
## First Naive Test
An even more brief look at `ElementType.TYPE_USE` [javadoc](http://docs.oracle.com/javase/8/docs/api/java/lang/annotation/ElementType.html#TYPE_USE)
and then a first naive test:
```
public List<@TypeUse String> typeUse() {
    @TypeUse String s = "abc";
    List<@TypeUse String> list = new ArrayList<>();
    list.add(s);
    list.add("def");
    boolean isTypeUse = "def" instanceof @TypeUse String;
    System.out.println("@TypeUse String: " + isTypeUse);
    return list;
}
```
**Wow! No compilation errors!!!**

---
layout: false
class: center, middle, inverse
# A Deeper Dive into Specification
## or a piece of more organized knowledge

---
layout: true
### A Deeper Dive into Specification

---
## Declaration vs type context

Before Java 8 annotations could be used only in *declaration contexts*, that is in declarations of types, fields, methods, constructors etc.
All the declarations contexts except for `ElementType.LOCAL_VARIABLE` could be accessed by reflection.

Java 8 extends *declaration context* to the use of **generic type parameter declarations**.

Additionally it introduces *type context*, where annotations apply to **types used in declarations and expressions**.

---
## Declaration context
* ElementType.PACKAGE
* ElementType.TYPE
* ElementType.ANNOTATION_TYPE
* ElementType.FIELD
* ElementType.CONSTRUCTOR
* ElementType.METHOD
* ElementType.PARAMETER
* .red[ElementType.LOCAL_VARIABLE]

---
## Declaration context
* ElementType.PACKAGE
* ElementType.TYPE
* ElementType.ANNOTATION_TYPE
* ElementType.FIELD
* ElementType.CONSTRUCTOR
* ElementType.METHOD
* ElementType.PARAMETER
* ElementType.LOCAL_VARIABLE
* .green[ElementType.TYPE_PARAMETER]

--

##.green[Type context]
* .green[ElementType.TYPE_USE]

---
## Declaration context
* ElementType.PACKAGE
* .blue[ElementType.TYPE]
* .blue[ElementType.ANNOTATION_TYPE]
* ElementType.FIELD
* ElementType.CONSTRUCTOR
* ElementType.METHOD
* ElementType.PARAMETER
* ElementType.LOCAL_VARIABLE
* .blue[ElementType.TYPE_PARAMETER]

## Type context
* .blue[ElementType.TYPE_USE]

`ElementType.TYPE_USE` for convenience .blue[includes elements of declaration context]: types, annotation types and type parameters.

---
## ElementType.TYPE_PARAMETER usages

Type parameter of generic class (or interface)
```
public class GenericClass<@TypeParameter V extends Number>
```
Type parameter of generic constructor
```
public <@TypeParameter A> GenericClass(V value, A another)
```
Type parameter of generic method
```
public <@TypeParameter K> Map<K, V> getSingletonMap(K key)
```

---
## ElementType.TYPE_PARAMETER reflection

Since Java 8 `java.lang.reflect.TypeVariable` interface extends `java.lang.reflect.AnnotatedElement` interface. Thus we can
access type parameter annotations like in the following code:

```
TypeVariable<Class<GenericClass>>[] typeParameters =
    GenericClass.class.getTypeParameters();
TypeParameter annotation =
        typeParameters[0].getAnnotation(TypeParameter.class);
```

---
## ElementType.TYPE_USE usages
### Declaration context
```
@TypeUse("class")
public class DeclarationContext
                <@TypeUse("type parameter") V extends Number> {

    public <@TypeUse("type parameter") K> Map<K, V> getMap(K key) {}

    @TypeUse("annotation") public @interface AnnotationExample {}
    @TypeUse("interface") public interface InterfaceExample {}
    @TypeUse("enum") public enum EnumExample {}
}
```
Usages of `ElementType.TYPE_USE` in declaration contexts can be easily accessed by reflection.
---
## ElementType.TYPE_USE usages
### Type context in declarations

**`extends`** or **`implements`** clause of a class declaration
```
public class TypeContext implements @TypeUse Serializable
```
**`extends`** clause of an interface declaration
```
public interface InterfaceExample extends @TypeUse Runnable
```
Return type of a method
```
public @TypeUse String getValue()
```
---
## ElementType.TYPE_USE usages
### Type context in declarations

**`throws`** clause of a method or constructor
```
public void throwException() throws @TypeUse Exception
```
**`extends`** clause of a type parameter declaration
```
public <N extends @TypeUse Number> Integer getInteger(N number)
```
Field declaration including an enum constant
```
private @TypeUse String value;
private enum Status {@TypeUse OK, @TypeUse ERROR}
```
---
## ElementType.TYPE_USE usages
### Type context in declarations

Formal parameter of a method, constructor, or lambda expression
```
public List<Car> filterCars(@TypeUse List<Car> cars, int year) {
    return cars.stream()
            .filter((@TypeUse Car c) -> c.getYear() == year)
            .collect(Collectors.toList());
}
```
Receiver parameter of a method (explicit **`this`** parameter)
```
public void show(@TypeUse TypeContext this, boolean other)
```
---
## ElementType.TYPE_USE usages
### Type context in declarations

Local variable declaration
```
@TypeUse Date date;
```
Exception parameter of a **`catch`** clause
```
catch (@TypeUse NumberFormatException e)
```

---
## ElementType.TYPE_USE usages
### .red[Type context in declarations != Declaration context]

Note that use of annotation of `ElementType.TYPE_USE` target in declarations of a field, method or
constructor return type, formal parameter of a method and a local variable may look like use of
annotations of declaration context: `FIELD`, `METHOD`, `CONSTRUCTOR`, `PARAMETER` and `LOCAL_VARIABLE` respectively.

.red[Don't be tricked!] These are not declaration context usages and can't be accessed by reflection. For example:
```
private @TypeUse String value;

TypeContext.class.getDeclaredField("value")
        .getDeclaredAnnotation(TypeUse.class)
```
returns `null`.
---
## ElementType.TYPE_USE usages
### Type context in expressions

Explicit type parameter of a constructor or method invocation or **`new`** operator
```
<@TypeUse Long>this(0l);
new <@TypeUse String> GenericClass<@TypeUse Long>(123l, "abc")
        .<@TypeUse Integer> getSingletonMap(123);

```
Class instance creation (including anonymous)
```
new @TypeUse Thread(new @TypeUse Runnable() {
    @Override
    public void run() {}
});

```
---
## ElementType.TYPE_USE usages
### Type context in expressions

Type of element in array creation
```
Integer[] array = new Integer @TypeUse[] {};
```
Cast operator
```
String s = (@TypeUse String) "abc";
```
**`instanceof`** operator
```
boolean isInstance = s instanceof @TypeUse String;
```
---
## ElementType.TYPE_USE usages
### Type context in expressions

Method reference expression
```
@TypeUse GenericClass::new
List<@TypeUse String>::size
Arrays::<@TypeUse Integer> sort
```

Element type of an array
```
@TypeUse int[] a;    // annotates the primitive type int
int @TypeUse[] b;    // annotates the array type int[]
int @TypeUse[][] c;  // annotates the array type int[][]
int [] @TypeUse[] d; // annotates the array type int[] as component
                     // of array int[][]
```

---
## ElementType.TYPE_USE usages
### Type context in expressions

Type argument of a parametrized type
```
List<@TypeUse Integer> integers;
Set<? extends @TypeUse Number> set;
Collection<? super @TypeUse Number> collection = new ArrayList<>();
```
---
## .red[Quasi ElementType.TYPE_USE usages]

.red[Warning! The following are not type uses and such annotations are not allowed here]

```
// Annotation uses
@/* quasi @TypeUse */Deprecated String s;

// Class literal
Class<GenericClass> clazz = /* quasi @TypeUse */GenericClass.class;

// Import syntax
import java.io./* quasi @TypeUse */Serializable;

// Static member access
String title = /* quasi @TypeUse */ GenericClass.TITLE;

// Scoping (e.g. inner class)
String v = /* quasi @TypeUse */TypeContext.this.getValue();
```

---
layout: false
class: center, middle, inverse
# The Checker Framework
## or who is the main culprit?

---
layout: true
### The Checker Framework

---
## A piece of history

* Annotations on Java Types (JSR-308) won the Most Innovative Java SE/EE JSR of the Year award in... 2007 :)
* Rationale for this JSR was to allow building tools for more thorough source code analysis
* [The Checker Framework](http://types.cs.washington.edu/checker-framework/), an extendable set of compiler plugins that
  find bugs or verify their absence, was naturally the first tool to use JSR-308 specification
* They didn't waste their time for those 7 years and the framework with a bunch of tools is already up and running:
    * **Type annotations compiler** - replacing `javac`, processing also annotations written in comments: `/* @TypeUse */`
    * **Inference tools** - automatically adding annotations to your code
    * **Annotations File Utilities** - to process `.java` and `.class` files, write annotations in a separate file etc.
* Better late than never - .red[type annotations in Java 8] in 2014 :)

---
## What do we have out of the box?
.pull-left[
* Nullness Checker
* Initialization Checker
* Map Key Checker
* Interning Checker
* Lock Checker
* Fake Enum Checker
* Tainting Checker
* Regex Checker
]
.pull-right[
* Format String Checker
* Property File Checker
* Internationalization Checker
* Signature String Checker
* Units Checker
* Linear Checker
* Mutation Checkers
* Subtyping Checker
]

Each checker comes with a set of suitable annotations and an algorithm of checking constraints
declared by them.

???

1. Nullness Checker - null pointer errors
1. Initialization Checker - czy wszystkie pola ustawione w konstruktorze
1. Map Key Checker - jakie wartosci sa kluczami w mapach
1. Interning Checker - bledy uzycia porownania referencji zamiast equals
1. Lock Checker - bledy wspolbieznosci i blokowania
1. Fake Enum Checker - stale string int jako enumy
1. Tainting Checker - bledy bezpieczenstwa, sql injection
1. Regex Checker - prawidlowe wyrazenia regularne
1. Format String Checker - prawidlowe stringi formatujace
1. Property File Checker - prawidlowe klucze plikow properties
1. Internationalization Checker - prawidlowa internacjonalizacja
1. Signature String Checker - Class.forName, odpowiednie uzycie nazw klas
1. Units Checker - uzycie odpowiednich jednostek (np sekundy a milisekundy)
1. Linear Checker - zapobieganie re-uzywaniu referencji
1. Mutation Checkers - niepozadane efekty uboczne
1. Subtyping Checker - kwalifikatory typu

---
## Annotations as Type Qualifiers

In the Checker Framework type annotations act as type qualifiers:

* **`@Nullable Integer`** - an `Integer` that may become `null`
* **`@NonNull Date`** - a `Date` that will never become `null`
* **`@Regex String`** - a `String` that is a valid regular expression
* **`@Tainted String`** - a `String` that may contain dangerous content
* **`@Untainted String`** - a `String` that has been checked and is safe to be used
* **`@Interned Integer`** - an `Integer` that can be safely tested for equality by reference comparison `==`
* **`@ReadOnly List<String>`** - a read-only list of `String` objects

---
## Tainting Checker Type Hierarchy
.center[![tainting](tainting.png)]

---
## Tainting Checker SQL Injection Prevention

Security sink in an application, it should allow only untainted values:
```
public String createQuery(@Untainted String lastName) {
    return "SELECT p.id FROM person p " +
            "WHERE p.last_name = " + lastName;
}
```
Method to sanitize values entered from the outside:
```
public @Untainted String sanitize(@Tainted String tainted) {
    for (char c : tainted.toCharArray()) {
        if (!Character.isLetterOrDigit(c)
            && !Character.isWhitespace(c)) {
            throw new IllegalArgumentException("SQL Injection!");
        }
    }
    return new @Untainted String(tainted);
}
```

---
## Tainting Checker SQL Injection Prevention

Proper, safe use of security sink:
```
public String getSafeQuery(@Tainted String lastName) {
    return createQuery(sanitize(lastName));
}
```
Vulnerability in code:
```
public String getVulnerableQuery(@Tainted String lastName) {
    // use of a @Tainted String without sanitizing
    return createQuery(lastName);
}
```

---
## Tainting Checker SQL Injection Prevention
Compiler doesn't warn, despite the vulnerability in code.

However Tainting Checker **finds a security hole**:
```no-highlight
[INFO] --- checkerframework-maven-plugin:1.8.0:check (default)
    @ java8-type-annotations ---
[INFO] Running Checker Framework version: 1.8.0
[INFO] Running processor(s):
    org.checkerframework.checker.tainting.TaintingChecker
[INFO] Run with debug logging in order to view the compiler command line
[WARNING] ...src\main\java\pl\jug\warszawa\typeannotations\checker\
    TaintingExample.java:[31,27]
    [argument.type.incompatible] incompatible types in argument.
  found   : @Tainted String
  required: @Untainted String
```

**Et voilà!**

---
layout: false
class: inverse
# Links

### JSR-308 Specification
http://types.cs.washington.edu/jsr308/specification/java-annotation-design.html
### Java 8 Language Specification - 9.6.4.1. `@Target`
http://docs.oracle.com/javase/specs/jls/se8/html/jls-9.html#jls-9.6.4.1
### The Checker Framework
http://types.cs.washington.edu/checker-framework/
### Source code of this presentation
https://github.com/danielstankiewicz/type-annotations

---
layout: false
class: center, middle, inverse

# The End

Slideshow created with [remark](http://gnab.github.com/remark).

    </textarea>
    <script>
      var slideshow = remark.create({
            ratio: '4:3',
            highlightLanguage: 'java', 
            highlightStyle: 'github'
      });
    </script>
  </body>
</html>