<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>Java 8: Type Annotations</title>
    <script src="http://gnab.github.io/remark/downloads/remark-0.6.4.min.js" type="text/javascript"> </script>
    <style type="text/css">
      @import url(http://fonts.googleapis.com/css?family=Signika:300);
      @import url(http://fonts.googleapis.com/css?family=Source+Code+Pro);
      @import url(http://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);

      body { 
        font-family: 'Signika';
        font-weight: 300;
        font-size: 18pt;
      }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: 400;
        margin-bottom: 0;
        margin-top: 10px;
      }
      h1 { font-size: 2.5em; }
      h2 { font-size: 2em; }
      h3 { font-size: 1.5em; }

      .inverse {
        background: #272822;
        color: #a5a5a5;
      }
      .inverse h1 {
        color: #f3f3f3;
        line-height: 1.5em;
      }
      .inverse h2, .inverse h3 {
        color: #a5a5a5;
        line-height: 0.8em;
      }
      .inverse em {
        color: #f3f3f3;
        font-style: normal;
      }
      pre {
        border-left: 0.2em solid #d7d7d7;
        padding: 0.3em !important;
      }
      code {
        font-family: 'Source Code Pro';
        font-size: 0.72em;
      }
      a {
        color: #F92672;
        text-decoration: none;
      }
      .right {
        float: right;
        margin-left: 1em;
      }
      .pushdown {
        margin-top: 12em;
      }
      .pull-left {
        float: left;
        width: 47%;
      }
      .pull-right {
        float: right;
        width: 47%;
      }
      .blue {
        color: #4A6BD9;
      }
      .red {
        color: #C90000;
      }
      .green {
        color: #1FAB3B;
      }
      img[alt=tainting] {
        width: 60%;
      }

    </style>
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse
# Java 8: Type Annotations

## by [Daniel Stankiewicz](https://github.com/danielstankiewicz)

---
class: center, middle, inverse
# about.me
### (mostly) Java Developer since 2005
### currently [@AssecoPolandSA](http://asseco.com/pl/home-en/)
### *inspired by Java 8*
### privately husband, dad, guitarist

---
class: center, middle, inverse
# Java 8 New Features
## and Type Annotations amongst them

---
layout: true

### Java 8 New Features

---
## Annotations on Java Types (JSR-308)
Browsing [JDK 8 Features](http://openjdk.java.net/projects/jdk8/features) in `core/lang` group:

* 101 Generalized Target-Type Inference
* .blue[**104 Annotations on Java Types**]
* 105 DocTree API
* 106 Add Javadoc to `javax.tools`
* 117 Remove the Annotation-Processing Tool (apt)
* 118 Access to Parameter Names at Runtime
* 120 Repeating Annotations
* ...

A brief look at [Open JDK Type Annotations](http://openjdk.java.net/projects/type-annotations/) project:

*JSR 308, Annotations on Java Types lays the foundations for stronger typing in Java by extending
the language to .blue[**allow annotations**] on essentially .blue[**any use of a type**].*

???
Gdy przegladalem liste ficzerow Java 8, zwrocilem uwage na wpis Adnotacje na typach Java.

Adnotacje, odkad pojawily sie w Javie 5, byly jednym z moich ulubionych narzedzi,
wiec pomyslalem, ze to cos dla mnie.

Szybki rzut oka na projekt Open JDK Type Annotations - JSR 308 to rozszerzenie jezyka
o mozliwosc adnotowania dowolnego uzycia typu.

---
## First Naive Test
An even more brief look at `ElementType.TYPE_USE` [javadoc](http://docs.oracle.com/javase/8/docs/api/java/lang/annotation/ElementType.html#TYPE_USE)
and then a first naive test:
```
public List<@TypeUse String> typeUse() {
    @TypeUse String s = "abc";
    List<@TypeUse String> list = new ArrayList<>();
    list.add(s);
    list.add("def");
    boolean isTypeUse = "def" instanceof @TypeUse String;
    System.out.println("@TypeUse String: " + isTypeUse);
    return list;
}
```
**Wow! No compilation errors!!!**

???

Pierwszy naiwny test, wow, zadnych bledow kompilacji. Swoja droga, co zawiera zmienna isTypeUse? Oczywiscie true.
---
layout: false
class: center, middle, inverse
# A Deeper Dive into Specification
## or a piece of more organized knowledge

???

No dobrze, na razie niewiele z tego wynika. Pora na zaglebienie sie w specyfikacje

---
layout: true
### A Deeper Dive into Specification

---
## Declaration vs type context

Before Java 8 annotations could be used only in *declaration contexts*, that is in declarations of types, fields, methods, constructors etc.
All the declarations contexts except for `ElementType.LOCAL_VARIABLE` could be accessed by reflection.

Java 8 extends *declaration context* to the use of **generic type parameter declarations**.

Additionally it introduces *type context*, where annotations apply to **types used in declarations and expressions**.

???
Przed Java 8 adnotacje mogly byc uzywane tylko w kontekscie deklaracji, czyli w deklaracjach typow, pol, metod, konstruktorow i tak dalej.

Java 8 rozszerza kontekst deklaracji o generyki.

Dodatkowo wprowadza pojecie kontekstu typu, gdzie adnotuje sie typy uzyte w deklaracjach i wyrazeniach.

---
## Declaration context @Target
* ElementType.PACKAGE
* ElementType.TYPE
* ElementType.ANNOTATION_TYPE
* ElementType.FIELD
* ElementType.CONSTRUCTOR
* ElementType.METHOD
* ElementType.PARAMETER
* .red[ElementType.LOCAL_VARIABLE]

???
Kontekst deklaracji zawieral do tej pory deklaracje: pakietu, typu, adnotacji, pola, konstruktora, metody, parametru i zmiennej lokalnej.

Zmienna lokalna na czerwono, bo to byl jedyny typ, gdzie do adnotacji nie mozna bylo sie dostac przez refleksje.

---
## Declaration context @Target
* ElementType.PACKAGE
* ElementType.TYPE
* ElementType.ANNOTATION_TYPE
* ElementType.FIELD
* ElementType.CONSTRUCTOR
* ElementType.METHOD
* ElementType.PARAMETER
* ElementType.LOCAL_VARIABLE
* .green[ElementType.TYPE_PARAMETER]

???
Kontekst deklaracji zostaje w Javie 8 rozszerzony o deklaracje typu parametryzowanego.

--

##.green[Type context @Target]
* .green[ElementType.TYPE_USE]

???
Pojawia sie nowy kontekst typu, oznaczany przez @Target ElementType.TYPE_USE

---
## Declaration context @Target
* ElementType.PACKAGE
* .blue[ElementType.TYPE]
* .blue[ElementType.ANNOTATION_TYPE]
* ElementType.FIELD
* ElementType.CONSTRUCTOR
* ElementType.METHOD
* ElementType.PARAMETER
* ElementType.LOCAL_VARIABLE
* .blue[ElementType.TYPE_PARAMETER]

## Type context @Target
* .blue[ElementType.TYPE_USE]

`ElementType.TYPE_USE` for convenience .blue[includes elements of declaration context]: types, annotation types and type parameters.

???

Dla wygody TYPE_USE zawiera w sobie takze elementy z kontekstu deklaracji: deklaracje typow (takze adnotacji) oraz parametrow typu (generykow).

---
## ElementType.TYPE_PARAMETER usages

Type parameter of generic class (or interface)
```
public class GenericClass<@TypeParameter V extends Number>
```
Type parameter of generic constructor
```
public <@TypeParameter A> GenericClass(V value, A another)
```
Type parameter of generic method
```
public <@TypeParameter K> Map<K, V> getSingletonMap(K key)
```

???

Uzycia TYPE_PARAMETER to deklaracje parametru typu w klasie (czy tez interfejsie), konstruktorze lub metodzie

---
## ElementType.TYPE_PARAMETER reflection

Since Java 8 `java.lang.reflect.TypeVariable` interface extends `java.lang.reflect.AnnotatedElement` interface. Thus we can
access type parameter annotations like in the following code:

```
TypeVariable<Class<GenericClass>>[] typeParameters =
    GenericClass.class.getTypeParameters();
TypeParameter annotation =
        typeParameters[0].getAnnotation(TypeParameter.class);
```

???
Do adnotacji o typie TYPE_PARAMETER mozna sie dostawac przez refleksje, tak jak do pozostalych z kontekstu deklaracji,
poniewaz TypeVariable od Javy 8 rozszerza AnnotatedElement

---
## ElementType.TYPE_USE usages
### Declaration context
```
@TypeUse("class")
public class DeclarationContext
                <@TypeUse("type parameter") V extends Number> {

    public <@TypeUse("type parameter") K> Map<K, V> getMap(K key) {}

    @TypeUse("annotation") public @interface AnnotationExample {}
    @TypeUse("interface") public interface InterfaceExample {}
    @TypeUse("enum") public enum EnumExample {}
}
```
Usages of `ElementType.TYPE_USE` in declaration contexts can be easily accessed by reflection.

???
Adnotacja typu TYPE_USE moze byc uzywana w kontekscie deklaracji: klasy, parametru typu, adnotacji, interfejsu, enuma.

Wtedy mozemy sie do niego dostawac przez refleksje, bo jest to tylko taki skrot, dla wygody, do targetu TYPE czy TYPE_PARAMETER.
---
## ElementType.TYPE_USE usages
### Type context in declarations

**`extends`** or **`implements`** clause of a class declaration
```
public class TypeContext implements @TypeUse Serializable
```
**`extends`** clause of an interface declaration
```
public interface InterfaceExample extends @TypeUse Runnable
```
Return type of a method
```
public @TypeUse String getValue()
```
???
Rzeczywiste uzycia TYPE_USE w kontekscie typu dziela sie na uzycia typu w deklaracjach i wyrazeniach.

Uzycia w deklaracjach to na przyklad:

w deklaracjach typow, po slowach kluczowych extends lub implements klas ktore rozszerzamy lub interfejsow, ktore implementujemy

w deklaracjach metod, przy typie zwracanym

---
## ElementType.TYPE_USE usages
### Type context in declarations

**`throws`** clause of a method or constructor
```
public void throwException() throws @TypeUse Exception
```
**`extends`** clause of a type parameter declaration
```
public <N extends @TypeUse Number> Integer getInteger(N number)
```
Field declaration including an enum constant
```
private @TypeUse String value;
private enum Status {@TypeUse OK, @TypeUse ERROR}
```

???
w deklaracjach metod przy rzucanych wyjatkach

po slowie kluczowym extends w deklaracji parametru typu

w deklaracjach pol, lacznie ze stalymi enuma

---
## ElementType.TYPE_USE usages
### Type context in declarations

Formal parameter of a method, constructor, or lambda expression
```
public List<Car> filterCars(@TypeUse List<Car> cars, int year) {
    return cars.stream()
            .filter((@TypeUse Car c) -> c.getYear() == year)
            .collect(Collectors.toList());
}
```
Receiver parameter of a method (explicit **`this`** parameter)
```
public void show(@TypeUse TypeContext this, boolean other)
```
???
w parametrach metod, konstruktorow i wyrazen lambda

oraz w domniemanym parametrze this metody

---
## ElementType.TYPE_USE usages
### Type context in declarations

Local variable declaration
```
@TypeUse Date date;
```
Exception parameter of a **`catch`** clause
```
catch (@TypeUse NumberFormatException e)
```
???
w deklaracji zmiennej lokalnej

w deklaracji wyjatku lapanego w klauzuli catch

---
## ElementType.TYPE_USE usages
### .red[Type context in declarations != Declaration context]

The above may look like use of annotations of declaration context: `FIELD`, `METHOD`, `CONSTRUCTOR`, `PARAMETER` and `LOCAL_VARIABLE`.

.red[Don't be tricked!] These are not declaration context usages and can't be accessed by reflection. For example:
```
private @TypeUse String value;

TypeContext.class.getDeclaredField("value")
        .getDeclaredAnnotation(TypeUse.class)
```
returns `null`.

???
.red[Tutaj wazna uwaga:] kontekst typu uzytego w deklaracjach to cos innego niz kontekst deklaracji.

Niekture uzycia adnotacji w kontekscie typu uzytego w deklaracji: pola, metody, konstruktora, parametru metody i zmiennej lokalnej
moga wygladac jak odpowiednie uzycia adnotacji z kontekstu deklaracji. Ale to tylko zludzenie! Nie da sie do nich dostac przez refleksje.

---
## ElementType.TYPE_USE usages
### Type context in expressions

Explicit type parameter of a constructor or method invocation or **`new`** operator
```
<@TypeUse Long>this(0l);
new <@TypeUse String> GenericClass<@TypeUse Long>(123l, "abc")
        .<@TypeUse Integer> getSingletonMap(123);

```
Class instance creation (including anonymous)
```
new @TypeUse Thread(new @TypeUse Runnable() {
    @Override
    public void run() {}
});

```
???
Teraz uzycia kontekstu typu w wyrazeniach:

przy jawnym uzyciu parametru typu w wywolaniu konstruktora, metody lub przy uzyciu operatora new

przy typie uzytym w tworzeniu instancji klasy, takze anonimowej

---
## ElementType.TYPE_USE usages
### Type context in expressions

Type of element in array creation
```
Integer[] array = new Integer @TypeUse[] {};
```
Cast operator
```
String s = (@TypeUse String) "abc";
```
**`instanceof`** operator
```
boolean isInstance = s instanceof @TypeUse String;
```

???
przy typie elementu tablicy

przy typie w operatorach rzutowania i instanceof

---
## ElementType.TYPE_USE usages
### Type context in expressions

Method reference expression
```
@TypeUse GenericClass::new
List<@TypeUse String>::size
Arrays::<@TypeUse Integer> sort
```

Element type of an array
```
@TypeUse int[] a;    // annotates the primitive type int
int @TypeUse[] b;    // annotates the array type int[]
int @TypeUse[][] c;  // annotates the array type int[][]
int [] @TypeUse[] d; // annotates the array type int[] as component
                     // of array int[][]
```

???
W referencjach do metod

przy typach elementow tablic na roznych poziomach w przypadku tablic wielowymiarowych

---
## ElementType.TYPE_USE usages
### Type context in expressions

Type argument of a parametrized type
```
List<@TypeUse Integer> integers;
Set<? extends @TypeUse Number> set;
Collection<? super @TypeUse Number> collection = new ArrayList<>();
```
???

Przy parametrach typu w typach parametryzowanych.

---
## .red[Quasi ElementType.TYPE_USE usages]

.red[Warning! The following are not type uses and such annotations are not allowed here]

```
// Annotation uses
@/* quasi @TypeUse */Deprecated String s;

// Class literal
Class<GenericClass> clazz = /* quasi @TypeUse */GenericClass.class;

// Import syntax
import java.io./* quasi @TypeUse */Serializable;

// Static member access
String title = /* quasi @TypeUse */ GenericClass.TITLE;

// Scoping (e.g. inner class)
String v = /* quasi @TypeUse */TypeContext.this.getValue();
```

???
Uwaga, sa tez miejsca, gdzie tylko wydaje nam sie, ze jest to uzycie typu i ze mozna tam postawic adnotacje. Sa to:

uzycie adnotacji

uzycie literalu class

import

dostep do statycznego pola czy metody

okreslenia zakresu (np. dostep do metod klasy zewnetrznej w klasie wewnetrznej)

---
layout: false
class: center, middle, inverse
# The Checker Framework
## or who is the main culprit?

???
Jak widac, jest tego duzo i mozemy teraz tak napisac kod, ze bedzie w nim wiecej adnotacji, niz samego kodu.

Ale skad to sie wszystko wzielo i kto jest glownym winowajca tego calego zamieszania?

---
layout: true
### The Checker Framework

---
## A piece of history

* Rationale for JSR-308 was to allow building tools for more thorough source code analysis
* Annotations on Java Types (JSR-308) won the Most Innovative Java SE/EE JSR of the Year award in... 2007 :)
* [The Checker Framework](http://types.cs.washington.edu/checker-framework/), an extendable set of compiler plugins that
  find bugs or verify their absence, was naturally the first tool to use JSR-308 specification
* The framework with a bunch of tools is already up and running:
    * **Type annotations compiler** - replacing `javac`, processing also annotations written in comments: `/* @TypeUse */`
    * **Inference tools** - automatically adding annotations to your code
    * **Annotations File Utilities** - to process `.java` and `.class` files, write annotations in a separate file etc.
    * **IDE and build tools plugins**
* Better late than never - .red[type annotations in Java 8] in 2014 :)

???
Troszeczke historii. Wszystko zaczelo sie dawno, dawno temu, gdy na uniwersytecie w Waszyngtonie pan doktor Ernst
chcial rozszerzyc Jave o mozliwosc bardziej szczegolowej analizy kodu przez narzedzia do szukania bledow.

Specyfikacja wygrala nagrode dla najbardziej innowacyjnego JSRa w 2007 roku :)

Pierwszym narzedziem, ktory uzywal JSR-308 byl Checker Framework, rozwijany przez te same osoby, ktore specyfikowaly JSRa.

Nie tracili czasu przez te 7 lat i powstal sam framework oraz komplet narzedzi, gotowych i dzialajacych:

* kompilator adnotacji typu - zastepujacy standardowy kompilator javy, rozpoznajacy adnotacje typow, takze w komentarzach (da kompatybilnosci)

* narzedzia automatycznego adnotowania istniejacego kodu i procesowania adnotacji w plikach .java i .class

* zestaw pluginow do IDE czy Mavena

wreszcie lepiej pozno niz pozniej - adnotacje typow pojawily sie w 2014 roku w Javie 8

---
## What do we have out of the box?
.pull-left[
* Nullness Checker
* Initialization Checker
* Map Key Checker
* Interning Checker
* Lock Checker
* Fake Enum Checker
* Tainting Checker
* Regex Checker
]
.pull-right[
* Format String Checker
* Property File Checker
* Internationalization Checker
* Signature String Checker
* Units Checker
* Linear Checker
* Mutation Checkers
* Subtyping Checker
]

Each checker comes with a set of suitable annotations and an algorithm of checking constraints
declared by them.

We have also pre-annotated JDK classes and ability to annotate external libraries by file stubs.

???

Co mamy dostepne w pudelku zwanym Checker Framework? Wielki zestaw wbudowanych Checkerow, kazdy definujacy wlasny zestaw adnotacji i algorytm
sprawdzania. Mamy tez mozliwosc latwego pisania wlasnych

Dostajemy rowniez preadnotowane JDK i mozliwosc wlasnorecznego adnotowania zewnetrznych bilbiotek poprzez stuby.

1. Nullness Checker - null pointer errors
1. Initialization Checker - czy wszystkie pola ustawione w konstruktorze
1. Map Key Checker - jakie wartosci sa kluczami w mapach
1. Interning Checker - bledy uzycia porownania referencji zamiast equals
1. Lock Checker - bledy wspolbieznosci i blokowania
1. Fake Enum Checker - stale string int jako enumy
1. Tainting Checker - bledy bezpieczenstwa, sql injection
1. Regex Checker - prawidlowe wyrazenia regularne
1. Format String Checker - prawidlowe stringi formatujace
1. Property File Checker - prawidlowe klucze plikow properties
1. Internationalization Checker - prawidlowa internacjonalizacja
1. Signature String Checker - Class.forName, odpowiednie uzycie nazw klas
1. Units Checker - uzycie odpowiednich jednostek (np sekundy a milisekundy)
1. Linear Checker - zapobieganie re-uzywaniu referencji
1. Mutation Checkers - niepozadane efekty uboczne
1. Subtyping Checker - kwalifikatory typu

---
## Annotations as Type Qualifiers

In the Checker Framework type annotations act as type qualifiers:

* **`@Nullable Integer`** - an `Integer` that may become `null`
* **`@NonNull Date`** - a `Date` that will never become `null`
* **`@Regex String`** - a `String` that is a valid regular expression
* **`@Tainted String`** - a `String` that may contain dangerous content
* **`@Untainted String`** - a `String` that has been checked and is safe to be used
* **`@Interned Integer`** - an `Integer` that can be safely tested for equality by reference comparison `==`
* **`@ReadOnly List<String>`** - a read-only list of `String` objects

???

W Checker Framework adnotacje dzialaja jak kwalifikatory typow:

typ Integer, ktory moze miec wartosc null

typ Date, ktory nigdy nie bedzie miec wartosci null

typ String, ktory jest wyrazeniem regularnym

typ String, ktory moze zawierac niebezpieczna tresc, np. SQL injection

typ String, ktory na pewno zawiera bezpieczna tresc

internowany typ Integer, czyli taki, w ktorym obiekty mozna bezpieczenie porownywac przez referencje zamiast equals

lista obiektow Stringow z dostepem tylko do odczytu

---
## Tainting Checker Type Hierarchy
.center[![tainting](tainting.png)]

???
zobaczmy na hierarchie typow, definiowana przez Tainting Checker

ooo... wielokrotne dziedziczenie w Javie :)

Nie musimy adnotowac wszystkiego, bo w tym przypadku @Tainted jest wartoscia domyslna.

---
## Tainting Checker SQL Injection Prevention

Security sink in an application, it should allow only untainted values:
```
public String createQuery(@Untainted String lastName) {
    return "SELECT p.id FROM person p " +
            "WHERE p.last_name = " + lastName;
}
```
Method to sanitize values entered from the outside:
```
public @Untainted String sanitize(@Tainted String tainted) {
    for (char c : tainted.toCharArray()) {
        if (!Character.isLetterOrDigit(c)
            && !Character.isWhitespace(c)) {
            throw new IllegalArgumentException("SQL Injection!");
        }
    }
    return new @Untainted String(tainted);
}
```
???

Sprawdzimy jak mozna uzyc Tainting Checker do zapobiegania SQL injection

Mamy takie miejsce w aplikacji, w ktorym niebezpiecznie jest uzywac niesprawdzonych wartosci

Jest nim tutaj konstruowanie zapytania do bazy przez konkatenacje z wartoscia pobierana od uzytkownika.

Trzeba to miejsce oadnotowac, ze przyjmuje tylko nieskazone Stringi jako parametr.

Metoda sanitize sprawdza, czy string jest bezpieczny i jesli tak, to zwraca String oznaczony jako nieskazony.

---
## Tainting Checker SQL Injection Prevention

Proper, safe use of security sink:
```
public String getSafeQuery(@Tainted String lastName) {
    return createQuery(sanitize(lastName));
}
```
Vulnerability in code:
```
public String getVulnerableQuery(@Tainted String lastName) {
    // use of a @Tainted String without sanitizing
    return createQuery(lastName);
}
```

???

Prawidlowe, bezpieczne uzycie wartosci przekazanej przez uzytkownika polega na jej sprawdzeniu przed przekazaniem do wrazliwego kodu.

Dziura bezpieczenstwa polega na bezposrednim uzyciu wartosci bez uzycia metody sanitize.

---
## Tainting Checker SQL Injection Prevention
Compiler doesn't warn, despite the vulnerability in code.

However Tainting Checker **finds a security hole**:
```no-highlight
[INFO] --- checkerframework-maven-plugin:1.8.0:check (default)
    @ java8-type-annotations ---
[INFO] Running Checker Framework version: 1.8.0
[INFO] Running processor(s):
    org.checkerframework.checker.tainting.TaintingChecker
[INFO] Run with debug logging in order to view the compiler command line
[WARNING] ...src\main\java\pl\jug\warszawa\typeannotations\checker\
    TaintingExample.java:[31,27]
    [argument.type.incompatible] incompatible types in argument.
  found   : @Tainted String
  required: @Untainted String
```

**Et voilà!**

???

Kompilator oczywiscie nie zglasza zadnych problemow, ale juz Tainting Checker z Checker Framework stwierdza,
ze uzyty zostal skazony String, a oczekiwano nieskazonego.

---
layout: false
class: inverse
# Links

### JSR-308 Specification
http://types.cs.washington.edu/jsr308/specification/java-annotation-design.html
### Java 8 Language Specification - 9.6.4.1. `@Target`
http://docs.oracle.com/javase/specs/jls/se8/html/jls-9.html#jls-9.6.4.1
### The Checker Framework
http://types.cs.washington.edu/checker-framework/
### Source code of this presentation
https://github.com/danielstankiewicz/type-annotations

???
Jeszcze garsc linkow, jakies pytania?

---
layout: false
class: center, middle, inverse

# The End

Slideshow created with [remark](http://gnab.github.com/remark).

    </textarea>
    <script>
      var slideshow = remark.create({
            ratio: '4:3',
            highlightLanguage: 'java', 
            highlightStyle: 'github'
      });
    </script>
  </body>
</html>